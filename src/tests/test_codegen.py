# Contains test cases for the CodeGenerator.

import os
import traceback
from lexer import tokenize, LexerError
from parser import Parser, ParserError
from codegen import CodeGenerator, CodeGenerationError

def run_codegen_tests():
    """Runs all codegen tests."""
    print("--- Running NotScheme Code Generator Tests (Focus on 'use') ---")

    # Create dummy module files for testing 'use'
    math_utils_content = """
    (struct Vec2 (x y))
    (static gravity 9.8)
    (fn square (val) (* val val))
    (fn add_vec (v1 v2) (Vec2 (+ (get v1 x) (get v2 x)) (+ (get v1 y) (get v2 y))))
    """
    string_ext_content = """
    (static greeting "Hello from string_ext module")
    (fn combine_strings (s1 s2) (string_append s1 s2)) 
    """ # string_append is not a primitive, for testing import resolution

    try:
        with open("math_utils.ns", "w") as f:
            f.write(math_utils_content)
        with open("string_ext.ns", "w") as f:
            f.write(string_ext_content)

        test_code_use_specific = """
        (use math_utils (gravity square Vec2 add_vec)) 
        (static my_g gravity)
        (static nine (square 3))
        (static v1 (Vec2 1 2))
        (static v2 (Vec2 3 4))
        (static v_sum (add_vec v1 v2)) 
        """
        test_code_use_all = """
        (use string_ext *)
        (print greeting)
        (print (combine_strings "Not" "Scheme"))
        """
        tests = {
            "Use Specific Items": test_code_use_specific,
            "Use All Items (*)": test_code_use_all,
        }

        for name, code in tests.items():
            print(f"\n--- Generating code for: {name} ---")
            print(f"Source:\n{code}")
            try:
                tokens = tokenize(code)
                parser = Parser(tokens)
                ast = parser.parse_program()

                # Each test run needs a fresh codegen instance and cache
                codegen = CodeGenerator(processed_modules_cache=set()) 
                bytecode, deps = codegen.generate_program(
                    ast, module_name=name.replace(" ", "_")
                )

                print("\nGenerated Bytecode:")
                for i, instruction in enumerate(bytecode):
                    print(f"{i:03d}: {instruction}")
                print(f"\nDiscovered dependencies: {deps}")
                print("\nCodegen Global Env (after this module's compilation):")
                for k, v_info in codegen.global_env.items():
                    print(f"  {k}: {v_info}")
                print("Codegen Struct Definitions (after this module's compilation):")
                for k, v_val in codegen.struct_definitions.items(): # Renamed v to v_val
                    print(f"  {k}: {v_val}")
                print(
                    f"Processed modules for defs cache (final): {codegen.processed_modules_for_defs}"
                )

            except (LexerError, ParserError, CodeGenerationError) as e:
                print(f"Error for '{name}': {e}")
                traceback.print_exc()

    finally:
        # Clean up dummy module files
        try:
            if os.path.exists("math_utils.ns"):
                os.remove("math_utils.ns")
            if os.path.exists("string_ext.ns"):
                os.remove("string_ext.ns")
        except OSError as e:
            print(f"Warning: Could not remove test module files: {e}")
            
    print("\n--- Codegen tests completed ---")

if __name__ == "__main__":
    import sys
    import os
    # Add src directory to sys.path to allow imports of lexer, parser etc.
    # when running this test script directly.
    # Project root is two levels up from src/tests/
    PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
    SRC_DIR = os.path.join(PROJECT_ROOT, 'src')
    if SRC_DIR not in sys.path:
        sys.path.insert(0, SRC_DIR)
    run_codegen_tests()
